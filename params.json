{"name":"Intel","tagline":"I need more intel!","body":"# intel\r\n\r\n[![Build Status](https://travis-ci.org/seanmonstar/intel.png?branch=master)](https://travis-ci.org/seanmonstar/intel)\r\n[![NPM version](https://badge.fury.io/js/intel.png)](http://badge.fury.io/js/intel)\r\n\r\nAn abbreviation of intelligence. In this case, the acquirement of information.\r\n\r\n> I'm ganna need more intel.\r\n\r\n## Motivation\r\n\r\nReally? Another logger? Well, yes. But here's why:\r\n\r\n\r\n- hierarchial named loggers\r\n- powerful config\r\n- console injection works with all libraries \r\n\r\n\r\n## Table of Contents\r\n\r\n- [Logging](#logging)\r\n  - [Using Default Logger](#using-default-logger)\r\n  - [String Interpolation](#string-interpolation)\r\n  - [Setting the Log Level](#setting-the-log-level)\r\n  - [Adding a Handler](#adding-a-handler)\r\n  - [Getting Named Loggers](#getting-a-named-logger)\r\n  - [Async Logging](#async-logging)\r\n- [Handlers](#handlers)\r\n  - [ConsoleHandler](#consolehandler)\r\n  - [StreamHandler](#streamhandler)\r\n  - [FileHandler](#filehandler)\r\n  - [NullHandler](#nullhandler)\r\n  - [Creating a Custom Handler](#creating-a-custom-handler)\r\n- [Formatters](#formatters)\r\n  - [LogRecord Formatting](#logrecord)\r\n- [config](#config)\r\n  - [basicConfig](#basicconfig)\r\n  - [Full Configuration](#full-configuration)\r\n- [console](#console)\r\n\r\n## Logging\r\n\r\n### Using Default Logger\r\n\r\nTo get started right away, intel provides a default logger. The module itself is an instance of a `Logger`.\r\n\r\n```js\r\nrequire('intel').info('Hello intel');\r\n```\r\n\r\n### String interpolation\r\n\r\nYou can log messages using interpolation just as you can when using the `console.log` API:\r\n\r\n```js\r\nrequire('intel').info('Situation %s!', 'NORMAL');\r\n```\r\n\r\n### Setting the Log Level\r\n\r\nLoggers have a log level that is compared against log messages. All messages that are of a lower level than the Logger are ignored. This is useful to reduce less important messages in production deployments.\r\n\r\n```js\r\nvar intel = require('intel');\r\nintel.setLevel(intel.WARN);\r\nintel.warn('i made it!');\r\nintel.debug('nobody loves me');\r\n```\r\n\r\n### Adding a Handler\r\n\r\nThe default logger will use a [ConsoleHandler](#consolehandler) if you don't specify anything else. You can add handlers to any logger:\r\n\r\n```js\r\nvar intel = require('intel');\r\nintel.addHandler(new intel.handlers.File('/path/to/file.log'));\r\n\r\nintel.info('going to a file!');\r\n```\r\n\r\n### Getting a Named Logger\r\n\r\nUsing named loggers gives you a lot of power in `intel`. First, the logger name can be included in the log message, so you can more easily understand where log messages are happening inside your application.\r\n\r\n```js\r\nvar log = require('intel').getLogger('foo.bar.baz');\r\nlog.setLevel(log.INFO).warn('baz reporting in');\r\n```\r\n\r\nThe names are used to build an hierarchy of loggers. Child loggers can inherit their parents' handlers and log level.\r\n\r\n```js\r\nvar intel = require('intel');\r\nvar alpha = intel.getLogger('alpha');\r\nalpha.setLevel(intel.WARN).addHandler(new intel.handlers.File('alpha.log'));\r\n\r\nvar bravo = intel.getLogger('alpha.bravo');\r\nbravo.verbose('hungry') // ignored, since alpha has level of WARN\r\nbravo.warn('enemy spotted'); // logged to alpha.log\r\n```\r\n\r\nThe power of logger hierarchies can seen more when using [intel.config](#config).\r\n\r\n### Async logging\r\n\r\nWith Nodejs' async nature, many handlers will be dealing with asynchronous APIs. In most cases, that shouldn't be your concern, and you can ignore this. However, if you need to execute code after a log message has been completely handled, every log method returns a promise. The promise only gets resolved after all handlers have finished handling that message.\r\n\r\n```js\r\nrequire('intel').warn('report in').then(rogerThat);\r\n```\r\n\r\n## Handlers\r\n\r\nLoggers build a message and try to pass the message to all of it's handlers and to it's parent. Handlers determine exactly what to do with that message, whether it's sending it to console, to a file, over a socket, or nothing at all.\r\n\r\nAll Handlers have a `level` and a [`Formatter`](#formatters).\r\n\r\n```js\r\nnew intel.Handler({\r\n  level: intel.WARN, // default is NOTSET\r\n  formatter: new intel.Formatter() // default formatter\r\n});\r\n```\r\n\r\nJust like Loggers, if a message's level is not equal to or greater than the Handler's level, the Handler won't even be given the message.\r\n\r\n### ConsoleHandler\r\n\r\n```js\r\nnew intel.handlers.Console(options);\r\n```\r\n\r\nThe Console handler outputs messages to the `stdio`, just like `console.log()` would.\r\n\r\n### StreamHandler\r\n\r\n```js\r\nnew intel.handlers.Stream(streamOrOptions);\r\n```\r\n\r\nThe Stream handler can take any writable stream, and will write messages to the stream. The [Console](#consolehandler) handler essentially uses 2 Stream handlers internally pointed at `process.stdout` and `process.stdin`.\r\n\r\n- **stream**: Any [WritableStream](http://nodejs.org/api/stream.html#stream_class_stream_writable)\r\n- Plus options from [Handler](#handlers)\r\n\r\nAs a shortcut, you can pass the `stream` directly to the constructor, and all other options will just use default values.\r\n\r\n### FileHandler\r\n\r\n```js\r\nnew intel.handlers.File(filenameOrOptions);\r\n```\r\n\r\nThe File handler will write messages to a file on disk. It extends the [Stream](#streamhandler) handler, by using the `WritableStream` created from the filename.\r\n\r\n- **file**: A string of a filename to write messages to.\r\n- Plus options from [Handler](#handlers)\r\n\r\nAs a shortcut, you can pass the `file` String directly to the constructor, and all other options will just use default values.\r\n\r\n### NullHandler\r\n\r\n```js\r\nnew intel.handlers.Null();\r\n```\r\n\r\nThe Null handler will do nothing with received messages. This can useful if there's instances where you wish to quiet certain loggers when in production (or enemy territory).\r\n\r\n### Creating Custom Handlers\r\n\r\nAdding a new custom handler that isn't included in intel is a snap. Just make a subclass of [Handler](#handlers), and implement the `emit` method.\r\n\r\n```js\r\nconst util = require('util');\r\nconst intel = require('intel');\r\n\r\nfunction CustomHandler(options) {\r\n  intel.Handler.call(this, options);\r\n  // whatever setup you need\r\n}\r\n// don't forget to inhert from Handler (or a subclass, like Stream)\r\nutil.inherits(CustomHandler, intel.Handler);\r\n\r\nCustomHandler.prototype.emit = function customEmit(record, callback) {\r\n  // do whatever you need to with the log record\r\n  // this could be storing it in a db, or sending an email, or sending an HTTP request...\r\n  // if you want the message formatted:\r\n  // str = this.format(record);\r\n\r\n  // The callback should be called indicating whether there was an error or not.\r\n  callback(err);\r\n}\r\n```\r\n\r\n## Formatters\r\n\r\n```js\r\nnew intel.Formatter(formatOrOptions);\r\n```\r\n\r\nA `Formatter` is used by a [`Handler`](#handlers) to format the message before being sent out. An useful example is wanting logs that go to the [Console](#consolehandler) to be terse and easy to read, but messages sent to a [File](#filehandler) to include a lot more detail.\r\n\r\n- **format**: A format string that will be used with `printf`. Default: `%(message)s`\r\n- **datefmt**: A string to be used to format the date. Will replace instances of `%(date)s` in the `format` string. Default: `%Y-%m-%d %H:%M-%S`\r\n- **colorize**: A boolean for whether to colorize the `levelname`. Default: `false`\r\n\r\n### LogRecord\r\n\r\nThe record that is created by loggers is passed to each handler, and handlers pass it to formatters to do their formatting.\r\n\r\n```js\r\n{\r\n  name: \"foo.bar\",\r\n  level: 20,\r\n  levelname: \"DEBUG\",\r\n  timestamp: new Date(),\r\n  message: \"all clear\",\r\n  args: []\r\n}\r\n```\r\n\r\nYou can output the values from these properties using the [Formatter](#formatters) and a string with `%(property)s`. Some example format strings:\r\n\r\n- `%(name)s.%(levelname)s: %(message)s`: foo.bar.DEBUG: all clear\r\n- `[%(date)s] %(name)s:: %(message)s`: \\[2013-09-18 11:29:32\\] foo.bar:: all clear\r\n\r\n## config\r\n\r\nOnce you understand the power of intel's [named loggers](#getting-a-named-logger), you'll appreciate being able to quickly configure logging in your application.\r\n\r\n### basicConfig\r\n\r\nThe basicConfig is useful if you don't wish to do any complicated configuration (no way, really?). It's a quick way to setup the root default logger in one function call. Note that if you don't setup any handlers before logging, `basicConfig` will be called to setup the default logger.\r\n\r\n```js\r\nintel.basicConfig({\r\n  'file': '/path/to/file.log', // file and stream are exclusive. only pass 1\r\n  'stream': stream,\r\n  'format': '%(message)s',\r\n  'level': intel.INFO\r\n});\r\n```\r\n\r\nThe options passed to basicConfig can include:\r\n- **file** - filename to log\r\n- **stream** - any WritableStream\r\n- **format** - a format string\r\n- **level** - the log level\r\n\r\nYou cannot pass a `file` and `stream` to basicConfig. If you don't provide either, a [Console](#consolehandler) handler will be used. If you wish to specify multiple or different handlers, take a look at the more comprehensive [config](#full-configuration).\r\n\r\n### Full Configuration\r\n\r\n```js\r\nintel.config({\r\n  formatters: {\r\n    'simple': {\r\n      'format': '[%(levelname)s] %(message)s',\r\n      'colorize': true\r\n    },\r\n    'details': {\r\n      'format': '[%(date)s] %(name)s.%(levelname)s: %(message)s'\r\n    }\r\n  }\r\n  handlers: {\r\n    'terminal': {\r\n      'class': intel.handlers.Console,\r\n      'formatter': 'simple',\r\n      'level': intel.VERBOSE\r\n    },\r\n    'logfile': {\r\n      'class': intel.handlers.File,\r\n      'level': intel.WARN,\r\n      'file': '/var/log/report.log',\r\n      'formatter': 'details'\r\n    }\r\n  },\r\n  loggers: {\r\n    'patrol': {\r\n      'handlers': ['terminal'],\r\n      'level': 'INFO',\r\n      'propagate': false\r\n    },\r\n    'patrol.db': {\r\n      'handlers': ['logfile'],\r\n      'level': intel.ERROR\r\n    },\r\n    'patrol.node_modules.express': { // huh what? see below :)\r\n      'handlers': ['logfile'],\r\n      'level': 'WARN'\r\n    }\r\n  }\r\n});\r\n```\r\n\r\nWe set up 2 handlers, one [Console](#consolehandler) with a level of `VERBOSE` and a simple format, and one [File](#filehandler) with a level of `WARN` and a detailed format. We then set up a few options on loggers. Not all loggers need to be defined here, as child loggers will inherit from their parents. So, the root logger that we'll use in this application is `patrol`. It will send all messages that are `INFO` and greater to the the terminal. We also specifically want database errors to be logged to the our log file. And, there's a logger for express? What's that all about? See the [intel.console](#console) section.\r\n\r\n## console\r\n\r\n```js\r\nrequire('intel').console();\r\n```\r\n\r\nSo, a problem with logging libraries is trying to get them to work with 3rd party modules. Many libraries may benefit from logging when certain things occur, but can't really pick a logging library, since that sort of choice should be up to the app developer. The only real options they have are to not log anything, or to use `console.log`. So really, they should [console.log() all the the things](http://seanmonstar.com/post/56448644049/console-log-all-the-things), and `intel` can work just fine with that.\r\n\r\nIntel has the ability to override the global `console`, such that calling any of it's methods will send it through a [Logger](#logging). This means that messages from other libraries can be sent to your log files, or through an email, or whatever. Even better, `intel` will automatically derive a name for the each module that access `console.log` (or `info`, `warn`, `dir`, `trace`, etc). In the [config](#full-configuration) example, we set up rules for `patrol.node_modules.express`. If `express` were to log things as it handled requests, they would all derive a name that was a child of our logger. So, in case it's chatty, we're only interesting in `WARN` or greater messages, and send those to a log file.\r\n\r\nIt tries its darndest to best guess a name, by comparing the relative paths from the `root` and the module accessing `console`. By default, the `root` is equal to the `dirname` of the module where you call `intel.console()`.\r\n\r\n```js\r\n// file: patrol/index.js\r\nrequire('intel').console(); // root is '/path/to/patrol'\r\n```\r\n\r\nIf you override the console in a file deep inside some directories, you can manually set the root as an option:\r\n\r\n```js\r\n// file: patrol/lib/utils/log.js\r\nrequire('intel').console({ root: '/path/to/patrol' });\r\n```\r\n\r\n","google":"UA-3472634-4","note":"Don't delete this file! It's used internally to help with page regeneration."}